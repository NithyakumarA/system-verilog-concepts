// ============================================================================
// WHY BASE CLASS HANDLES CAN'T ACCESS CHILD CLASS MEMBERS
// A Complete Explanation with Examples
// ============================================================================

// ============================================================================
// PART 1: THE FUNDAMENTAL CONCEPT - COMPILE TIME vs RUNTIME
// ============================================================================

class Animal;
   string name;
   int age;
   
   function new(string n, int a);
      name = n;
      age = a;
   endfunction
   
   virtual function void makeSound();
      $display("%s makes a sound", name);
   endfunction
endclass

class Dog extends Animal;
   string breed;      // NEW member - only in Dog
   int tail_length;   // NEW member - only in Dog
   
   function new(string n, int a, string b, int t);
      super.new(n, a);
      breed = b;
      tail_length = t;
   endfunction
   
   virtual function void makeSound();
      $display("%s the %s barks: Woof!", name, breed);
   endfunction
   
   // NEW method - only in Dog
   function void wagTail();
      $display("%s wags tail of length %0d", name, tail_length);
   endfunction
endclass

// ============================================================================
// PART 2: WHAT THE COMPILER KNOWS vs WHAT EXISTS AT RUNTIME
// ============================================================================

module compile_vs_runtime;
   initial begin
      $display("\n========== COMPILE TIME vs RUNTIME ==========\n");
      
      Animal animal_handle;  // ← COMPILE TIME: "This is an Animal handle"
      Dog dog_object;
      
      dog_object = new("Max", 3, "Golden Retriever", 15);
      
      // At COMPILE TIME, compiler only knows: "animal_handle is type Animal"
      // At RUNTIME, animal_handle will point to a Dog object
      animal_handle = dog_object;
      
      // ========================================================================
      // SCENARIO 1: Accessing BASE class members - ✅ WORKS
      // ========================================================================
      $display("--- Accessing Base Class Members ---");
      $display("Name: %s", animal_handle.name);   // ✅ Compiler: "Animal HAS name"
      $display("Age: %0d", animal_handle.age);    // ✅ Compiler: "Animal HAS age"
      
      // Compiler's thinking at COMPILE TIME:
      // "animal_handle is type Animal"
      // "Let me check Animal class... yes, it has 'name' and 'age'"
      // "APPROVED! This will compile."
      
      // ========================================================================
      // SCENARIO 2: Calling VIRTUAL methods - ✅ WORKS (Polymorphism!)
      // ========================================================================
      $display("\n--- Calling Virtual Methods ---");
      animal_handle.makeSound();  // ✅ Calls Dog's version at RUNTIME
      
      // Compiler's thinking at COMPILE TIME:
      // "animal_handle is type Animal"
      // "Let me check Animal class... yes, it has 'makeSound()' and it's virtual"
      // "APPROVED! I'll set up virtual dispatch mechanism."
      
      // At RUNTIME:
      // "animal_handle points to Dog object"
      // "makeSound() is virtual, so call Dog's version"
      // "Executes Dog::makeSound()"
      
      // ========================================================================
      // SCENARIO 3: Accessing CHILD class members - ❌ FAILS AT COMPILE TIME
      // ========================================================================
      $display("\n--- Attempting to Access Child Class Members ---");
      
      // ❌ This line won't even COMPILE!
      // $display("Breed: %s", animal_handle.breed);
      
      // Compiler's thinking at COMPILE TIME:
      // "animal_handle is type Animal"
      // "Let me check Animal class... NO 'breed' member found!"
      // "COMPILATION ERROR! Rejected before runtime."
      
      $display("Cannot access breed through animal_handle - won't compile!");
      
      // ✅ But we CAN access through dog_object (child handle)
      $display("Breed via dog_object: %s", dog_object.breed);  // ✅ Works!
      
      // Compiler's thinking:
      // "dog_object is type Dog"
      // "Let me check Dog class... yes, it has 'breed'"
      // "APPROVED!"
      
      // ========================================================================
      // SCENARIO 4: Calling CHILD-only methods - ❌ FAILS AT COMPILE TIME
      // ========================================================================
      $display("\n--- Attempting to Call Child-Only Methods ---");
      
      // ❌ This won't compile!
      // animal_handle.wagTail();
      
      // Compiler: "Animal class has no wagTail() method - ERROR!"
      
      $display("Cannot call wagTail() through animal_handle");
      
      // ✅ Works with child handle
      dog_object.wagTail();  // ✅ Compiler: "Dog has wagTail() - OK!"
   end
endmodule

// ============================================================================
// PART 3: THE MEMORY LAYOUT PERSPECTIVE
// ============================================================================

module memory_layout_explanation;
   initial begin
      $display("\n========== MEMORY LAYOUT PERSPECTIVE ==========\n");
      
      Animal a_handle;
      Dog d_object;
      
      d_object = new("Buddy", 5, "Labrador", 20);
      a_handle = d_object;
      
      $display("Memory layout of Dog object:");
      $display("┌─────────────────────────┐");
      $display("│  Animal part (BASE)     │");
      $display("│  - name: 'Buddy'        │ ← Animal handle can see THIS
");
      $display("│  - age: 5               │ ← Animal handle can see THIS");
      $display("│  - vtable pointer       │ ← For virtual methods");
      $display("├─────────────────────────┤");
      $display("│  Dog part (EXTENDED)    │");
      $display("│  - breed: 'Labrador'    │ ← Animal handle CANNOT see");
      $display("│  - tail_length: 20      │ ← Animal handle CANNOT see");
      $display("└─────────────────────────┘");
      $display("");
      
      $display("Animal handle 'a_handle' points to the WHOLE object,");
      $display("but can only ACCESS the Animal part (top section).");
      $display("");
      $display("It's like having a KEY that only unlocks certain rooms!");
   end
endmodule

// ============================================================================
// PART 4: WHY THIS DESIGN? - TYPE SAFETY EXAMPLES
// ============================================================================

class Vehicle;
   int speed;
   virtual function void move();
      $display("Vehicle moving at %0d km/h", speed);
   endfunction
endclass

class Car extends Vehicle;
   int num_doors;
   function void openDoors();
      $display("Opening %0d doors", num_doors);
   endfunction
endclass

class Boat extends Vehicle;
   int sail_size;
   function void hoistSail();
      $display("Hoisting sail of size %0d", sail_size);
   endfunction
endclass

module type_safety_example;
   initial begin
      $display("\n========== TYPE SAFETY EXAMPLES ==========\n");
      
      Vehicle v_handle;
      Car my_car;
      Boat my_boat;
      
      my_car = new();
      my_car.num_doors = 4;
      
      my_boat = new();
      my_boat.sail_size = 50;
      
      // ========================================================================
      // PROBLEM: What if base handle COULD access child members?
      // ========================================================================
      
      $display("--- Why Type Safety Matters ---");
      
      // Imagine if this was allowed (IT'S NOT!):
      v_handle = my_car;
      // v_handle.num_doors = 4;  // ❌ What if I do this?
      
      v_handle = my_boat;
      // v_handle.num_doors = 2;  // ❌ DISASTER! Boats don't have doors!
      
      $display("If base handle could access child members:");
      $display("- We could try to set 'num_doors' on a Boat object!");
      $display("- We could try to 'hoistSail' on a Car object!");
      $display("- Compiler couldn't catch these logical errors!");
      $display("- Programs would crash at runtime!");
      
      $display("\n✅ Type safety PREVENTS these mistakes at compile time!");
      
      // ========================================================================
      // CORRECT APPROACH: Use polymorphism for common behavior
      // ========================================================================
      
      $display("\n--- Correct Usage of Polymorphism ---");
      
      Vehicle vehicles[3];
      vehicles[0] = my_car;
      vehicles[1] = my_boat;
      vehicles[2] = new Vehicle();
      
      foreach(vehicles[i]) begin
         vehicles[i].speed = (i+1) * 30;
         vehicles[i].move();  // ✅ Works! All have move() method
      end
      
      // Can't call openDoors() or hoistSail() - they're vehicle-specific
      // This is CORRECT because not all vehicles have doors or sails!
   end
endmodule

// ============================================================================
// PART 5: THE REAL-WORLD ANALOGY
// ============================================================================

module real_world_analogy;
   initial begin
      $display("\n========== REAL-WORLD ANALOGIES ==========\n");
      
      $display("ANALOGY 1: The ID Card");
      $display("─────────────────────────────────────────");
      $display("You have a 'Student ID' card (base handle)");
      $display("You ARE a graduate student (child object)");
      $display("");
      $display("What you can access:");
      $display("✅ Basic student resources (library, cafeteria) - Everyone has");
      $display("❌ Graduate lab - ID says 'student', doesn't say 'graduate'");
      $display("");
      $display("Even though you ARE a graduate student,");
      $display("your basic Student ID doesn't PROVE it.");
      $display("You need your Graduate Student ID (child handle) for that!");
      
      $display("\n");
      
      $display("ANALOGY 2: The Remote Control");
      $display("─────────────────────────────────────────");
      $display("TV remote (base handle) → Can control Smart TV (child object)");
      $display("");
      $display("What you can do:");
      $display("✅ Power, Volume, Channel (all TVs have these)");
      $display("❌ Stream Netflix, Browse Internet (Smart TV features)");
      $display("");
      $display("The basic TV remote only has buttons for basic TV functions,");
      $display("even though the TV itself is smart and can do more!");
      $display("You need the Smart Remote (child handle) for advanced features.");
      
      $display("\n");
      
      $display("ANALOGY 3: The Building Security Badge");
      $display("─────────────────────────────────────────");
      $display("'Employee' badge (base handle) → Manager (child object)");
      $display("");
      $display("What doors open:");
      $display("✅ Main entrance, Cafeteria, Your office");
      $display("❌ Executive boardroom, Secure server room");
      $display("");
      $display("Even though you ARE a manager,");
      $display("your basic 'Employee' badge doesn't have those permissions.");
      $display("You need 'Manager' badge (child handle) for special access!");
   end
endmodule

// ============================================================================
// PART 6: WHAT ACTUALLY HAPPENS - STEP BY STEP
// ============================================================================

class Base;
   int x = 10;
   virtual function void show();
      $display("Base: x=%0d", x);
   endfunction
endclass

class Derived extends Base;
   int y = 20;
   virtual function void show();
      $display("Derived: x=%0d, y=%0d", x, y);
   endfunction
endclass

module step_by_step_explanation;
   initial begin
      $display("\n========== STEP-BY-STEP: WHAT HAPPENS ==========\n");
      
      Base b_handle;
      Derived d_object;
      
      $display("STEP 1: Create Derived object");
      d_object = new();
      $display("→ Memory allocated for FULL Derived object (x and y)");
      $display("→ x = 10, y = 20");
      
      $display("\nSTEP 2: Assign to Base handle");
      b_handle = d_object;
      $display("→ b_handle now points to the Derived object");
      $display("→ But b_handle's TYPE is still 'Base'");
      
      $display("\n--- COMPILE TIME CHECKING ---");
      $display("When you write: b_handle.x");
      $display("Compiler checks: Does Base class have 'x'? YES ✅");
      $display("Result: Compiles successfully");
      
      $display("\nWhen you write: b_handle.y");
      $display("Compiler checks: Does Base class have 'y'? NO ❌");
      $display("Result: COMPILATION ERROR before runtime");
      
      $display("\n--- RUNTIME BEHAVIOR ---");
      $display("Accessing b_handle.x:");
      $display("→ Compiler allowed it (Base has x)");
      $display("→ At runtime, finds x in the object");
      $display("→ Returns value: %0d", b_handle.x);
      
      $display("\nCalling b_handle.show():");
      $display("→ Compiler: Base has show(), it's virtual ✅");
      $display("→ Runtime: Check vtable - points to Derived::show()");
      $display("→ Calls Derived version:");
      b_handle.show();
      
      $display("\nTrying b_handle.y:");
      $display("→ Would never reach runtime - COMPILER STOPS IT");
      $display("→ Reason: Type system says 'Base handle can't access y'");
      $display("→ Even though y EXISTS in memory at runtime!");
   end
endmodule

// ============================================================================
// PART 7: THE COMPLETE PICTURE WITH SOLUTIONS
// ============================================================================

class Transaction;
   int addr;
   virtual function void print();
      $display("Transaction: addr=0x%0h", addr);
   endfunction
   
   // Solution: Provide virtual getter if base needs child data
   virtual function int getData();
      return 0;  // Base has no data
   endfunction
endclass

class WriteTransaction extends Transaction;
   int data;
   
   virtual function void print();
      $display("Write: addr=0x%0h, data=0x%0h", addr, data);
   endfunction
   
   virtual function int getData();
      return data;  // Child returns actual data
   endfunction
endclass

module complete_picture;
   initial begin
      $display("\n========== COMPLETE PICTURE WITH SOLUTIONS ==========\n");
      
      Transaction t_handle;
      WriteTransaction wt_object;
      
      wt_object = new();
      wt_object.addr = 'h1000;
      wt_object.data = 'hDEAD;
      
      t_handle = wt_object;
      
      $display("PROBLEM: Want to access 'data' through t_handle");
      $display("");
      
      // ❌ Won't compile: t_handle.data
      
      $display("SOLUTION 1: Use child handle directly");
      $display("→ wt_object.data = 0x%0h ✅", wt_object.data);
      
      $display("\nSOLUTION 2: Use $cast for safe downcasting");
      WriteTransaction casted;
      if ($cast(casted, t_handle)) begin
         $display("→ Downcast successful!");
         $display("→ casted.data = 0x%0h ✅", casted.data);
      end
      
      $display("\nSOLUTION 3: Virtual getter method (BEST for polymorphism)");
      $display("→ t_handle.getData() = 0x%0h ✅", t_handle.getData());
      $display("→ This works through base handle!");
      $display("→ Calls WriteTransaction's getData() due to virtual dispatch");
      
      $display("\nWHY SOLUTION 3 IS BEST:");
      $display("✅ Works with ANY transaction type");
      $display("✅ No downcasting needed");
      $display("✅ Type safe - compiler enforces interface");
      $display("✅ True polymorphism - base handle does everything");
   end
endmodule

// ============================================================================
// SUMMARY OF KEY CONCEPTS
// ============================================================================

/*

THE GOLDEN RULES:
═════════════════

1. HANDLE TYPE is checked at COMPILE TIME
   - Determines what members/methods are ACCESSIBLE
   - Based on the handle's declared type (Base/Child)

2. OBJECT TYPE matters at RUNTIME  
   - Determines which method EXECUTES (for virtual)
   - Based on actual object created with 'new'

3. TYPE SAFETY is the reason
   - Prevents accessing non-existent members
   - Catches errors at compile time, not runtime
   - Ensures program correctness

THE MEMORY MODEL:
═════════════════

Child Object in Memory:
┌──────────────────┐
│  BASE PART       │ ← Base handle can see
│  (inherited)     │
├──────────────────┤
│  CHILD PART      │ ← Base handle CANNOT see
│  (new members)   │
└──────────────────┘

WHY THIS RESTRICTION EXISTS:
════════════════════════════

1. TYPE SAFETY
   - Base handle doesn't know what child type it points to
   - Could point to Dog, Cat, Bird - they all have different members
   - Allowing access would cause crashes

2. COMPILE-TIME CHECKING
   - Compiler can verify correctness before running
   - Catches mistakes early
   - Better than runtime errors

3. POLYMORPHISM DESIGN
   - Forces you to use virtual methods (good design!)
   - Encourages proper abstraction
   - Base class defines the contract

4. MULTIPLE CHILD CLASSES
   - One base handle can point to many child types
   - Each child has different members
   - Compiler can't know which one at compile time

EXAMPLE OF THE PROBLEM IF ALLOWED:
═══════════════════════════════════

Vehicle v;
v = new Car();     // v.num_doors exists
v.num_doors = 4;   // OK

v = new Boat();    // v.num_doors doesn't exist!
v.num_doors = 2;   // CRASH! Boat has no doors!

See the problem? Base handle doesn't know which child!

THE SOLUTION:
═════════════

Use polymorphism correctly:
- Virtual methods for common behavior
- $cast when you need specific child access
- Virtual getters to access child data through base handle
- Keep child-specific code with child handles

BOTTOM LINE:
════════════
The handle is like a VIEW or FILTER through which you see the object.
A Base handle provides a "Base class view" - it can only see Base class members.
The ACTUAL object might have more, but the view is limited by the handle type.

This is NOT a limitation - it's a FEATURE that prevents bugs!

*/